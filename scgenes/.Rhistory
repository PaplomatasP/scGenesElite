}
row.names(PvalueTreshold) = PvalueTreshold[, 1]
PvalueData1 <-
data.frame(PvalueData[order(PvalueData$pvalue, decreasing = FALSE), drop = FALSE,])
View(PvalueData1)
iG1 = subset(PvalueData1 ,
rownames(PvalueData) %in% rownames(PvalueTreshold))
View(iG1)
iG = cbind((iG1[, -c(1, 2,4)]))
rownames(iG) = rownames(iG1)
iG <<- as.data.frame(round(iG, digits = 4))
View(iG)
iG <<- as.data.frame(round(iG, digits = 3))
View(iG1)
View(iG)
count = 0
PvalueTreshold = list()
print("here")
for (i in 1:nrow(PvalueData)) {
if (!is.na(PvalueData[, 3][i]) && PvalueData[, 3][i] <= threshold && abs(PvalueData[, 4][i]) >= logfc ) {  #threshold
print(i)
count = count + 1
PvalueTreshold[[count]] = rownames(PvalueData)[i]
}
}
count = 0
PvalueTreshold = list()
print("here")
for (i in 1:nrow(PvalueData)) {
if (!is.na(PvalueData[, 3][i]) && PvalueData[, 3][i] <= 0.01  && abs(PvalueData[, 4][i]) >= 2  ) {  #threshold
print(i)
count = count + 1
PvalueTreshold[[count]] = rownames(PvalueData)[i]
}
}
PvalueTreshold <<- as.data.frame(cbind(PvalueTreshold))
PvalueData<-as.data.frame(PvalueData)
PvalueData1 <- data.frame(PvalueData[order(PvalueData$pval, decreasing = FALSE), drop = FALSE,])
View(PvalueData1)
iG1 = subset(PvalueData1 , rownames(PvalueData1) %in% PvalueTreshold[, 1])
iG = cbind((iG1[, -c(1, 2, 4)]))
rownames(iG) = rownames(iG1)
iG <<- as.data.frame(round(iG, digits = 3))
View(iG)
iG <<- as.data.frame(round(iG, digits = 4))
View(iG)
obj = RDS_file1
neudata <- obj[, colnames(obj) %in% row.names(iG)]
neudata<-as.data.frame(neudata)
runApp()
runApp()
View(PvalueData)
count = 0
PvalueTreshold = list()
print("here")
for (i in 1:nrow(PvalueData)) {
if (!is.na(PvalueData[, 3][i]) && PvalueData[, 3][i] <= 0.01  && abs(PvalueData[, 4][i]) >= 2  ) {  #threshold logfc
print(i)
count = count + 1
PvalueTreshold[[count]] = rownames(PvalueData)[i]
}
}
PvalueTreshold <<- as.data.frame(cbind(PvalueTreshold))
print("here2")
View(PvalueTreshold)
PvalueData1 <- data.frame(PvalueData[order(PvalueData$pval, decreasing = FALSE), drop = FALSE,])
iG1 = subset(PvalueData1 , rownames(PvalueData1) %in% PvalueTreshold[, 1])
iG = cbind((iG1[, -c(1, 2, 4)]))
rownames(iG) = rownames(iG1)
iG <<- as.data.frame(round(iG, digits = 3))
View(iG)
runApp()
runApp()
View(PvalueData)
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
print(length(PvalueData))
print(nrow(PvalueData))
runApp()
shiny::runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
View(GenesList)
#
vote1 <-
create_vote(GenesList, xtype = 3, candidate = c(unique(unlist(GenesList))))
#
vote <-
create_vote(GenesList, xtype = 3, candidate = c(unlist(GenesList)))
View(vote)
View(vote1)
View(vote)
View(vote1)
vote1[["ballot"]]
a= vote1[["ballot"]]
View(a)
a=na.omit(a)
View(vote)
View(GenesList)
GenesList
borda_count <- function(rankings) {
# Create an empty vector to store the sum of rankings for each item
sum_rankings <- rep(0, length(rankings[[1]]))
# Go through each ranking and add the rank of each item to the sum of rankings
for (ranking in rankings) {
sum_rankings <- sum_rankings + match(rankings[[1]], ranking)
}
# Return the items ordered by their sum of rankings, breaking ties at random
return(rankings[[1]][order(sum_rankings, decreasing = TRUE)])
}
# Assuming expression levels (just an example)
expression_levels_DATA <- rnorm(length(DATA))
expression_levels_DATA4 <- rnorm(length(DATA4))
expression_levels_DATA8 <- rnorm(length(DATA8))
# Convert expression levels to rankings
rank_DATA <- DATA[order(expression_levels_DATA, decreasing = TRUE)]
rank_DATA4 <- DATA4[order(expression_levels_DATA4, decreasing = TRUE)]
rank_DATA8 <- DATA8[order(expression_levels_DATA8, decreasing = TRUE)]
rank_DATA8
# Compute Borda count
borda_count_result <- borda_count(list(rank_DATA, rank_DATA4, rank_DATA8))
View(borda_count_result)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
Echad35_results <- readRDS("C:/Users/ppapl/MEGA/Projects/2023/Genes.Ranking/Genes.Ranking/ScriptsRun/PlotsData/EvaluationResults/Echad35_results.rds")
emtab9221_results <- readRDS("C:/Users/ppapl/MEGA/Projects/2023/Genes.Ranking/Genes.Ranking/ScriptsRun/PlotsData/EvaluationResults/emtab9221_results.rds")
thca_gse_154763_results <- readRDS("C:/Users/ppapl/MEGA/Projects/2023/Genes.Ranking/Genes.Ranking/ScriptsRun/PlotsData/EvaluationResults/thca_gse_154763_results.rds")
egeod111727_results <- readRDS("C:/Users/ppapl/MEGA/Projects/2023/Genes.Ranking/Genes.Ranking/ScriptsRun/PlotsData/EvaluationResults/egeod111727_results.rds")
egeod86618_results_all <- readRDS("C:/Users/ppapl/MEGA/Projects/2023/Genes.Ranking/Genes.Ranking/ScriptsRun/PlotsData/EvaluationResults/egeod86618_results_all.rds")
# Put all datasets into a list
all_datasets <- list(egeod86618_results_all[[1]],
egeod111727_results[[1]], thca_gse_154763_results[[1]],
emtab9221_results[[1]], Echad35_results[[1]])
# Function to rank methods and split by Metrics in each dataset
rank_methods <- function(df) {
df %>%
group_by(Metrics, Methods) %>%
summarise(Mean = mean(metrics)) %>%
mutate(Rank = rank(-Mean)) %>%
arrange(Rank) %>%
split(.$Metrics)
}
# Rank methods in each dataset and split by Metrics
ranks <- lapply(all_datasets, rank_methods)
names(ranks)=c("egeod86618","egeod111727","thca_gse_154763","emtab9221","echad35")
Metrics=c("Accuracy","Sensitivity","Specificity","F1" )
RankingResults=vector(mode = "list",length = 4)
for ( i in 1:length(Metrics)){
#Ranking
raw <- c(
ranks[[1]][[Metrics[i]]]$Methods,
ranks[[2]][[Metrics[i]]]$Methods,
ranks[[3]][[Metrics[i]]]$Methods,
ranks[[4]][[Metrics[i]]]$Methods,
ranks[[5]][[Metrics[i]]]$Methods
)
raw1 = unique(raw) # This gets unique values from all the rank lists
raw <- matrix(raw, ncol =5  , byrow = TRUE)  #  ncol is the number of datasets
vote <- create_vote(raw, xtype = 2, candidate = c(raw1))
y <- borda_method(vote,modified = TRUE,allow_dup = TRUE,min_valid = 1)
RankingResults[[i]]=as.data.frame(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )
names(RankingResults)[i]=Metrics[i]
}
ranks[[1]][[Metrics[1]]]$Methods
raw <- c(
ranks[[1]][[Metrics[1]]]$Methods,
ranks[[2]][[Metrics[1]]]$Methods,
ranks[[3]][[Metrics[1]]]$Methods,
ranks[[4]][[Metrics[1]]]$Methods,
ranks[[5]][[Metrics[1]]]$Methods
)
# Rank methods in each dataset and split by Metrics
ranks <- lapply(all_datasets, rank_methods)
names(ranks)=c("egeod86618","egeod111727","thca_gse_154763","emtab9221","echad35")
View(ranks)
View(ranks[["egeod86618"]][["Accuracy"]])
Metrics=c("Accuracy","Sensitivity","Specificity","F1" )
RankingResults=vector(mode = "list",length = 4)
for ( i in 1:length(Metrics)){
#Ranking
raw <- c(
ranks[[1]][[Metrics[i]]]$Methods,
ranks[[2]][[Metrics[i]]]$Methods,
ranks[[3]][[Metrics[i]]]$Methods,
ranks[[4]][[Metrics[i]]]$Methods,
ranks[[5]][[Metrics[i]]]$Methods
)
}
rm(raw)
for ( i in 1:length(Metrics)){
#Ranking
raw <- c(
ranks[[1]][[Metrics[i]]]$Methods,
ranks[[2]][[Metrics[i]]]$Methods,
ranks[[3]][[Metrics[i]]]$Methods,
ranks[[4]][[Metrics[i]]]$Methods,
ranks[[5]][[Metrics[i]]]$Methods
)
}
raw1 = unique(raw) # This gets unique values from all the rank lists
raw <- matrix(raw, ncol =5  , byrow = TRUE)  #  ncol is the number of datasets
View(raw)
raw <- matrix(GenesList, ncol =length(GenesList)  , byrow = TRUE)
View(ranks)
ranks[["egeod86618"]]
ranks[[1]][[Metrics[1]]]$Methods
View(raw)
raw <- matrix(unlist(GenesList), ncol =length(GenesList)  , byrow = TRUE)
View(DATA)
genes1 =colnames(DATAunlist(GenesList))
unlist(GenesList)
GenesList <- GenesList
raw <- matrix(unlist(GenesList), ncol =length(GenesList)  , byrow = TRUE)
if (length(GenesList)>=2){
#
vote <-
create_vote(GenesList, xtype = 3, candidate = c(unique(unlist(GenesList))) )
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
newdata <- as.data.frame(RankingResults[1:input$genes,])
row.names(newdata) = rownames(RankingResults)[1:input$genes]
rownames(newdata)=ifelse(substr(rownames(newdata), 1, 1) == "X",substr(rownames(newdata), 2, nchar(rownames(newdata))), rownames(newdata))
iG <- newdata
genesNames=colnames(obj)[which(colnames(obj) %in% rownames(iG) ==TRUE)]
Genes=rownames(iG)[which(rownames(iG) %in% genesNames) ]
newdata <- obj[,  colnames(obj) %in% rownames(iG)]
iG=data.frame(iG[which(rownames(iG) %in% genesNames),] )
rownames(iG)=Genes
iG <<- iG
newdata <- cbind(as.data.frame(newdata), as.data.frame(as.factor(EnseLabels)) )
print("here!!!!")
print("Ensemble Method is Executed!!!")
FilterData <- newdata
return(FilterData)
}else {
shinyalert(title = "Message",type = "error",
text = "No method has been selected! Multiple methods must be selected in order to use the Ensemble method", closeOnClickOutside = TRUE)
}
View(FilterData)
#
vote <-
create_vote(GenesList, xtype = 3, candidate = c(unique(unlist(GenesList))) )
a=unique(raw)
length(a)
length(raw)
raw
length(raw)
length(unique(raw) )
onion()
raw
# Load required library
library(votesys)
# Your lists (substitute with your actual lists)
GenesList <- list(
DATA = c("gene1", "gene2", "gene3"),
DATA4 = c("gene1", "gene4"),
DATA8 = c("gene2", "gene3", "gene4", "gene5")
)
View(GenesList)
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
# Conduct Borda count
result <- borda_method(vote, modified = TRUE)
# Print results
print(result)
all_genes
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
View(ranking_matrix)
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
# Conduct Borda count
result <- borda_method(vote, modified = TRUE)
# Print results
print(result)
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
newdata <- as.data.frame(RankingResults[1:input$genes,])
View(RankingResults)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
newdata <- as.data.frame(RankingResults[1:input$genes,])
runApp()
?create_vote
runApp()
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
if (length(GenesList)>=2){
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
#
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
newdata <- as.data.frame(RankingResults[1:input$genes,])
row.names(newdata) = rownames(RankingResults)[1:input$genes]
rownames(newdata)=ifelse(substr(rownames(newdata), 1, 1) == "X",substr(rownames(newdata), 2, nchar(rownames(newdata))), rownames(newdata))
iG <- newdata
genesNames=colnames(obj)[which(colnames(obj) %in% rownames(iG) ==TRUE)]
Genes=rownames(iG)[which(rownames(iG) %in% genesNames) ]
newdata <- obj[,  colnames(obj) %in% rownames(iG)]
iG=data.frame(iG[which(rownames(iG) %in% genesNames),] )
rownames(iG)=Genes
iG <<- iG
newdata <- cbind(as.data.frame(newdata), as.data.frame(as.factor(EnseLabels)) )
print("here!!!!")
print("Ensemble Method is Executed!!!")
FilterData <- newdata
return(FilterData)
}else {
shinyalert(title = "Message",type = "error",
text = "No method has been selected! Multiple methods must be selected in order to use the Ensemble method", closeOnClickOutside = TRUE)
}
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
View(ranking_matrix)
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
#
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
#
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 2, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
y <- borda_method(vote, modified = TRUE)
y <- borda_method(vote, modified = FALSE)
#
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 2, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
s
# Create empty ranking matrix
ranking_matrix <- lapply(GenesList, function(x) match(all_genes, x))
ranking_matrix[["DATA4"]]
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Create empty ranking matrix
ranking_list <- lapply(GenesList, function(x) match(all_genes, x))
# Fill ranking matrix
# Genes not present in a list are assumed to be ranked last
ranking_list <- lapply(ranking_list, function(x) {
x[is.na(x)] <- max(x, na.rm = TRUE) + 1
x
})
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 2, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
# Create a vote object
vote <- create_vote(ranking_list, xtype = 3, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
vote
y <- borda_method(vote, modified = TRUE)
y <- borda_method(vote, modified = FALSE)
result <- borda_method(vote, modified = TRUE)
View(GenesList)
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_list <- lapply(GenesList, function(x) match(all_genes, x))
# Fill ranking matrix
# Genes not present in a list are assumed to be ranked last
ranking_list <- lapply(ranking_list, function(x) {
x[is.na(x)] <- max(x, na.rm = TRUE) + 1
x
})
# Create a vote object
vote <- create_vote(ranking_list, xtype = 3, candidate = all_genes)
y <- borda_method(vote, modified = FALSE)
?borda_method
# Create a vote object
vote <- create_vote(ranking_list, xtype = 3, candidate = all_genes)
y <- borda_method(vote, modified = FALSE)
View(ranking_list)
View(ranking_list)
ranking_list[["DATA8"]]
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
#
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 2, candidate = all_genes)
y <- borda_method(vote, modified = TRUE)
y <- borda_method(vote)
ranking_matrix
ranking_matrix
# Your lists (substitute with your actual lists)
GenesList1 <- list(
DATA = c("gene1", "gene2", "gene3"),
DATA4 = c("gene1", "gene4"),
DATA8 = c("gene2", "gene3", "gene4", "gene5")
)
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create empty ranking matrix
ranking_matrix <- matrix(NA, nrow = length(all_genes), ncol = length(GenesList),
dimnames = list(all_genes, names(GenesList)))
# Fill ranking matrix
for (i in seq_along(GenesList)) {
# Ranking is the position of the gene in the list
ranking_matrix[GenesList[[i]], i] <- seq_along(GenesList[[i]])
}
# Genes not present in a list are assumed to be ranked last
ranking_matrix[is.na(ranking_matrix)] <- nrow(ranking_matrix) + 1
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 3, candidate = all_genes)
# Create a vote object
vote <- create_vote(as.data.frame(t(ranking_matrix)), xtype = 2, candidate = all_genes)
# Conduct Borda count
result <- borda_method(vote, modified = TRUE)
# Load required library
library(votesys)
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create a vote object
vote <- create_vote(GenesList, xtype = 3, candidate = all_genes)
# Conduct Borda count
result <- borda_method(vote, modified = TRUE)
# Print results
print(result)
# Create a vote object
vote <- create_vote(GenesList, xtype = 3, candidate = all_genes)
# Conduct Borda count
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
View(RankingResults)
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create a vote object
vote <- create_vote(GenesList, xtype = 3, candidate = all_genes)
# Conduct Borda count
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
runApp()
# Combine all lists into one vector of unique gene names
all_genes <- unique(unlist(GenesList))
# Create a vote object
vote <- create_vote(GenesList, xtype = 3, candidate = all_genes)
# Conduct Borda count
y <- borda_method(vote, modified = TRUE)
RankingResults=as.data.frame(cbind(sort(y[["other_info"]][["count_max"]],decreasing = TRUE ) )  )
newdata <- as.data.frame(RankingResults[1:input$genes,])
newdata <- as.data.frame(RankingResults)
row.names(newdata) = rownames(RankingResults)
rownames(newdata)=ifelse(substr(rownames(newdata), 1, 1) == "X",substr(rownames(newdata), 2, nchar(rownames(newdata))), rownames(newdata))
iG <- newdata
genesNames=colnames(obj)[which(colnames(obj) %in% rownames(iG) ==TRUE)]
View(iG)
runApp()
runApp()
View(GenesList)
View(GenesList)
runApp()
runApp()
runApp()
